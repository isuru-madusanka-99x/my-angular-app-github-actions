# =============================================================================
# WORKFLOW 2: Deploy on Self-Hosted Runner (Behind VPN)
# File: .github/workflows/deploy.yml
# =============================================================================
---
  name: Deploy to Windows Server
  
  on:
    workflow_dispatch:
      inputs:
        version:
          description: 'Release tag (e.g., v1.0.0) or leave empty for latest'
          required: false
  
  jobs:
    deploy:
      runs-on: self-hosted
      
      # Set default shell with Bypass execution policy for all steps
      defaults:
        run:
          shell: powershell -ExecutionPolicy Bypass -Command "& '{0}'"
      
      steps:
        - name: Verify PowerShell execution
          run: |
            Write-Host "PowerShell execution policy is now bypassed for all steps"
            Write-Host "Execution Policy: $(Get-ExecutionPolicy)"
  
        - name: Get version to deploy
          id: version
          run: |
            if ("${{ inputs.version }}" -eq "") {
              # Get latest release
              $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers @{Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}"}
              $version = $releases[0].tag_name
            } else {
              $version = "${{ inputs.version }}"
            }
            echo "tag=$version" >> $env:GITHUB_OUTPUT
            Write-Host "Deploying version: $version"
  
        - name: Download package
          run: |
            $version = "${{ steps.version.outputs.tag }}"
            
            # Get release info
            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/$version" -Headers @{Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}"}
            
            # Find tar.gz file
            $asset = $release.assets | Where-Object { $_.name -like "*.tar.gz" } | Select-Object -First 1
            
            # Download
            New-Item -ItemType Directory -Path "C:\temp\deploy" -Force
            Invoke-WebRequest -Uri $asset.browser_download_url -OutFile "C:\temp\deploy\app.tar.gz" -Headers @{Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}"}
  
            - name: Deploy to IIS
            run: |
              # Configuration
              $webRoot = "C:\inetpub\wwwroot\myapp"
              $siteName = "Default Web Site"
              
              # Stop IIS using appcmd (more reliable than PowerShell cmdlets)
              Write-Host "Stopping website: $siteName"
              & "${env:SystemRoot}\System32\inetsrv\appcmd.exe" stop site "$siteName"
              
              # Backup existing files
              if (Test-Path $webRoot) {
                $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
                $backupPath = "${webRoot}_backup_$timestamp"
                Write-Host "Creating backup at: $backupPath"
                Copy-Item -Path $webRoot -Destination $backupPath -Recurse
              }
              
              # Clear directory
              Write-Host "Clearing web root: $webRoot"
              Remove-Item -Path "$webRoot\*" -Recurse -Force -ErrorAction SilentlyContinue
              New-Item -ItemType Directory -Path $webRoot -Force
              
              # Extract files
              Write-Host "Extracting application files"
              Set-Location $webRoot
              tar -xzf "C:\temp\deploy\app.tar.gz"
              
              # Set permissions
              Write-Host "Setting file permissions"
              $acl = Get-Acl $webRoot
              $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS", "ReadAndExecute", "ContainerInherit,ObjectInherit", "None", "Allow")
              $acl.SetAccessRule($rule)
              Set-Acl -Path $webRoot -AclObject $acl
              
              # Start IIS using appcmd
              Write-Host "Starting website: $siteName"
              & "${env:SystemRoot}\System32\inetsrv\appcmd.exe" start site "$siteName"
              
              Write-Host "Deployment completed successfully!"
  
        - name: Verify deployment
          run: |
            Start-Sleep -Seconds 5
            
            $response = Invoke-WebRequest -Uri "http://localhost/myapp" -UseBasicParsing
            
            if ($response.StatusCode -eq 200) {
              Write-Host "✅ Deployment verified successfully"
            } else {
              Write-Error "❌ Deployment verification failed"
              exit 1
            }
  
        - name: Cleanup
          if: always()
          run: |
            Remove-Item -Path "C:\temp\deploy" -Recurse -Force -ErrorAction SilentlyContinue